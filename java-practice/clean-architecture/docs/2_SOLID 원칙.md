좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.  
좋은 벽돌을 사용하지 않으면 빌딩의 아키텍처가 좋고 나쁨은 그리 큰 의미가 없다.  
반대로 좋은 벽돌을 사용하더라도 빌딩의 아키텍처를 엉망으로 만들 수 있다.  

SOLID 는 좋은 벽돌로 좋은 아키텍쳐를 정의하는 원칙이다.  

SOLID 원칙은 객체 지향 소프트웨어에만 적용되는 것은 아니다.  
함수와 데이터를 결합한 집합(클래스일 수도, 아닐 수도)들을 서로 결합시키는 방법을 설명해준다.  

SOLID 원칙은 너무 낮은 코드 레벨 수준이 아니며, 너무 높은 수준의 아키텍쳐 레벨도 아닌  
중간 수준의 구조를 아래와 같도록 만드는 데 있다.  

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 _사용될 수 있는_ 컴포넌트의 기반이 된다.

# SRP: 단일 책임 원칙 (Single Responsibility Principle)

하나의 일만하는 것은, 함수에 국한된다.  
SRP는 단일 모듈과 하나의 액터에 대한 단일 책임을 일컫는다.  
단일 액터를 책임지는 코드를 함께 묶어주는 것이 `응집성`이다.  

- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

# OCP: 개발 폐쇄 원칙 (Open-Closed Principle)

요구사항을 살짝 확장하는 데 많은 수정이 발생한다면 시스템 구조가 실패한 것이다.  
고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조가 만들어지도록 해야 한다.  

아키텍쳐가 훌륭하다면 이상적인 변경량은 0이 된다. SRP 와 요소들의 의존성을 체계화함으로써(DIP) 변경량을 최소화할 수 있다.  
두 개의 책임으로 분리된 `A-1`, `A-2` 가 있다면, 각각 서로의 변경에 대한 영향은 제로다.  
`A` 컴포넌트에서 발생한 _변경_ 으로부터 `B` 컴포넌트를 보호하려면, `A` 가 `B` 에 의존해야 한다.  
이를 바탕으로 저수준의 정책이 고수준의 정책을 향하도록 설계해야 한다.  

- 확장에는 열려 있고, 변경에는 닫혀 있어야 한다.

# LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)

단순히 상속을 가이드하는 것을 넘어서 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙이다.  
`is-a` 관계만 될 때 사용할 수 있고, 쓸 수 없는 override 는 에러를 발생시킨다.  

정사각형/직사각형 문제는 전형적으로 LSP 를 위반하며, 상위 타입은 하위 타입의 더 큰 집합이 아니다.

- 하위 타입을 상위 타입으로 대체해도 시스템은 정상 동작해야 한다.

# ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)

의존성은 변경을 암시한다. `A` 가 `B` 를 의존하는 경우 `B`의 변경은 `A` 에게 전파된다.  
사용하지 않는 것에 의존하면 변경의 전파가 넒어지며 SRP 를 위반하게 되고 아키텍쳐가 흔들린다.

- 불필요한 의존성은 변경의 원인이 된다. 사용하지 않는 것에 의존하지 마라.

# DIP: 의존성 역전 원칙 (Dependency Inversion Principle)

추상화를 통해 의존하게 한다. 변경이 잦은 저수준 모듈에게 중요한 정책(비즈니스 로직)이 의존하게 되면 안 된다.  
구체적인 요소는 변동성이 크다. 구체적인 요소에 의존할 수록 변경에 대해 영향을 받는다.  

의존성 규칙을 더 추상적인 엔티티가 있는 쪽으로 흐르도록 설계한다.  

- 고수준 모듈은 저수준 모듈에 의존하면 안 된다.