# 인덱스

인덱스는 쿼리 성능을 향상 시키기 위해 빼놓을 수 없는 부분이다. 인덱스를 알아보기 전에 알아봐야할 배경 지식을 설명하고<br/>
인덱스를 사용했을 때 왜 성능이 좋아지며, 어떻게 사용해야하는지 설명한다.<br/>

## 디스크 읽기 방식, 랜덤 I/O 와 순차 I/O

데이터를 저장한다는 건 디스크 원판에 기록한다는 것이다.  
디스크 안에는 회전하는 **원판**이 있고 이를 읽고 쓰는 **헤더**가 있다.  
데이터를 0과 1로 변환해 원판의 자성을 조작해 기록하게 된다.

우리가 알고 있는 HDD(하드 디스크 드라이브), SSD(솔리드 스테이트 드라이브) 등의 장치를 말하며,     
SSD 는 HHD 에서 원판 대신 플래시 메모리를 장착하고 있어 원판을 기계적으로 회전시킬 필요가 없으므로 HDD 에 비해 매우 빠른 속도로 읽고 쓸 수 있다.  

이때문에 SSD 의 장점은 HDD 보다 랜덤 I/O 가 훨씬 빠르다는 것이다.  
데이터베이스 서버에서 일반적으로는 순차 I/O 작업보다는 랜덤 I/O 작업의 비중이 크므로 SSD 는 DBMS 용 최적의 스토리지라 볼 수 있다.


## 랜덤 I/O 와 순차 I/O

랜덤,순차 I/O 는 디스크의 원판을 돌려서 데이터가 저장된 위치로 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.  
하지만 작업 속도에서는 차이가 있는데, 예를 들어 3개의 페이지(3x16KB) 를 디스크에 기록한다면 순차 I/O 인 경우 1번 시스템 콜을 요청하지만,  
랜덤 I/O 인 경우에는 3번 시스템 콜을 요청한다. 즉 순차 I/O 는 헤더를 1번 움직이고 랜덤 I/O 는 헤더를 3번 움직인다.  
데이터를 읽고 쓰는데 걸리는 시간은 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정된다.  
SSD 는 디스크 원판이 없지만 랜덤 I/O 와 순차 I/O 의 차이가 존재한다.  

쿼리를 튜닝해서 랜덤 I/O 를 순차 I/O 로 바꾸는 방법은 많지 않다.  
_일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이라 할 수 있다._  

# 인덱스

우리는 책의 맨 마지막 부분에 '찾아보기(또는 색인)'가 있는 것을 알고 있다.  
맨 마지막 페이지에는 한글 순서(혹은 알파벳)로 정렬되어 있는 목차가 있는데  
"ㄱ", "ㄴ", "ㄷ" 순서대로 정렬되어 있으며 전체 내용이 아닌 키워드만 있다. (가끔 요약된 내용이 있을 수 있다.)  
그리고 해당 내용이 어떻게 적혀져 있는지 쪽수가 나와있다.  

여기서 중요한 부분은,  
**키워드**가 순서대로 **정렬**되어 있다. 그리고 자세한 내용이 몇 페이지에 있는 **쪽수**가 있다는 것이다.

DMBS 의 인덱스도 마찬가지다.  
컬럼의 값을 주어진 순서대로 미리 정렬을 해놓고 레코드가 있는 위치를 기록해둔다.
새로운 레코드가 추가될 때도 주어진 순서대로 재정렬이 이루어지므로 인덱스는 쓰기 작업(INSERT, UPDATE, DELETE)에 대해서 느리다.  
읽기(SELECT)의 성능을 높이는 대신 쓰기(INSERT, UPDATE, DELETE)의 성능을 희생하는 것과 같다.  

얼마나 트레이드 오프할지를 결정해야 하며 모든 컬럼을 인덱스로 두는 것은 역효과가 난다.  
(책에 맨 마지막 부분인 '찾아보기(또는 색인)' 부분이 책의 절반 이상을 차지한다고 생각한다면 쉽게 납득이 간다.)  

PRIMARY KEY 는 그 레코드를 대표는 컬럼의 값으로 만들어지는 인덱스를 말하며, 이를 제외한 모든 인덱스는 세컨더리 인덱스로 분류한다.  

# B-Tree

대표적인 인덱스 알고리즘으로 'Balanced-Tree' 이다. (_Binary 아니다._)  
구조 덕분에 데이터를 빠르게 찾을 수 있는데 B-Tree 는 *루트 노드 - 브랜치 노드 - 리프 노드 - 데이터 파일* 로 트리 구조로 이루어져 있으며 컬럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태로 유지한다.  
- 루트 노드: 트리의 최상단 노드로 검색은 항상 여기서 시작된다.
- 브랜치 노드: 중간 단계의 노드로 자식 노드(리프 노드)가 있으며 부모 노드가 있다.
- 리프 노드: 마지막 노드이며 실제 데이터가 저장된 페이지랑 연결되어있다.

도서관에서 책을 찾는 과정과 비슷한데 원하는 책이 어느 책장에 있는지 찾아보고 그 책장으로 가서 책을 찾는 것과 같다.  
(책은 도서관에서 발부한 코드를 기준으로 항상 정렬되어 있다.)  

## MyISAM 과 InnoDB 에서 B-Tree 의 차이

기본 원리는 동일하지만 인덱스와 데이터 연결 방식이 다르다.  

MyISAM  
- 인덱스와 데이터가 분리되어있다.
- B-Tree 인덱스는 데이터의 물리적 주소(파일 위치)를 저장한다.

InnoDB
- PRIMARY KEY 인덱스와 실제 데이터가 동일한 B-Tree 에 저장된다.(리프 노드에 실제 데이터 포함)
- 보조 인덱스는 PRIMARY KEY 값을 참조하여 데이터를 찾는다.

# 선택도(기수성, Selectivity, Cardinality)

모든 인덱스 키 값 가운데 *유니크한 값의 수*를 말한다. 전체 인덱스 키 값이 1_000개 일 때, 유니크한 값의 수가 10개라면 기수성은 10이다.  
선택도는 비율을 일컫는다. 전체 데이터가 1_000개 이며 기수성이 10일 때 선택도는 0.01이다.  
여기서 중요한 부분은 평균적으로 조회되는 데이터의 크기인데,  
- 전체 데이터: 1000, 기수성: 10 = 평균조회 100개  
- 전체 데이터: 1000, 기수성: 1 = 평균조회 1000개  
- 전체 데이터: 1000, 기수성: 999 = 평균조회 2개