# 4장 클래스, 객체, 인터페이스

- 코틀린의 인터페이스는 자바 인터페이스와 비슷하지만 디폴트 구현과 프로퍼티도 포함할 수 있다.
- 모든 코틀린 선언은 기본적으로 `final` 이며 `public` 이다.
- 선언이 `final` 이 되지 않게 만들려면(상속과 오버로딩이 가능하게 하려면) 앞에 `open` 을 붙여야 한다.
- `internal` 선언은 같은 모듈 안에서만 볼 수 있다.
- 내포 클래스는 기본적으로 내부 클래스가 아니다. 바깥쪽 클래스에 대한 참조를 내포 클래스 안에 포함시키려면 `inner` 키워드를 클래스 선언 앞에 붙여야 한다.
- `sealed` 클래스를 직접 상속하는 클래스나 `sealed` 인터페이스에 대한 구현들은 모두 컴파일 시점에 컴파일러에 보여아 한다.
- 초기화 블록과 부 생성자를 활용해 클래스 인스턴스를 더 유연하게 초기화할 수 있다.
- `field` 식별자를 통해 프로퍼티 접근자(게터와 세터) 안에서 프로퍼티의 데이터를 저장하는 데 뒷받침하는 필드를 참조할 수 있다.
- 데이터 클래스를 사용하면 컴파일러가 `equals`, `hashCode`, `toString`, `copy` 등의 메서드를 자동으로 생성해준다.
- 클래스 위임을 사용하면 위임 패턴을 구현할 때 비슷한 위임 코드를 반복하는 것을 피할 수 있다.
- 객체 선언은 싱글턴 클래스를 정의하는 코틀린식 방법이다.
- (패키지 수준 함수와 프로퍼티와 더불어) 동반 객체는 자바의 정적 메서드와 필드 정의를 대신한다.
- 동반 객체도 다른 (싱글턴) 객체와 마찬가지로 인터페이스를 구현할 수 있으며, 동반 객체에 대해서도 확장 함수와 프로퍼티를 정의할 수 있다.
- 코틀린의 객체 식은 자바의 익명 내부 클래스를 대신하며, 여러 인터페이스를 구현하거나 객체가 포함된 영역에 있는 변수의 값을 변경할 수 있는 등 자바 익명 내부 클래스보다 더 많은 기능을 제공한다.
- 인라인 클래스를 사용하면 수명이 짧은 객체를 많이 할당함으로써 발생할 수 있는 성능 저하를 피하면서도 프로그램에 새로운 타입 안전성 계층을 추가할 수 있다.