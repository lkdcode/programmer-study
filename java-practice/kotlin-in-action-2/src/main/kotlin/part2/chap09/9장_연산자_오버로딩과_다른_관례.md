# 9장 연산자 오버로딩과 다른 관례

- 코틀린은 정해진 이름의 함수를 정의함으로써 표준적인 수학 연산을 오버로드할 수 있게 해준다.
자신만의 연산자를 정의할 수는 없지만 중위 함수를 더 표현력이 좋은 대안으로 사용할 수 있다.
- 비교 연산자(`==`, `!=`, `>`, `<` 등)를 모든 객체에 사용할 수 있다. 비교 연산자는 `equals` 와 `compareTo` 메서드 호출로 변환된다.
- `get`, `set`, `contains` 라는 함수를 정의하면 코틀린 컬렉션과 비슷하게 여러분 클래스의 인스턴스에 대해 `[]`와 `in` 연산을 사용할 수 있다.
- 미리 정해진 관례를 따라 범위를 만들거나 컬렉션과 배열의 원소를 이터레이션할 수 있다.
- 구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있다. 함수가 여러 값을 한꺼번에 반환해야 하는 경우 구조 분해가 유용하다.
데이터 클래스에 대해 구조 분해를 거저 사용할 수 있지만, 자신의 클래스에 `componentN` 함수를 정의하면 구조 분해를 지원할 수 있다.
- 위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있다. 위임 프로퍼티는 프레임워크를 만들 때 아주 강력한 도구로 쓰인다.
- 표준 라이브러리 함수인 `lazy` 를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있다.
- `Delegates.observable` 함수를 사용하면 프로퍼티 변경을 관찰할 수 있는 옵저버를 쉽게 추가할 수 있다.
- 맵을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있다.