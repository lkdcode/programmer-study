# 설계 품질과 트레이드오프

객지향 설계의 핵심은 역할, 책임, 협력이다. 협력은 애플리케이션의 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용이다.<br/>
책임은 객체가 다른 객체와 협력하기 위해 수행하는 행동이고, 역할은 대체 가능한 책임의 집합이다.<br/>

**객체지향 설계란 올바른 객체에서 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다.**<br/>

객체지향 설계의 핵심이 책임이라는 것이다.<br/>
책임을 할당하는 작업이 응집도와 결합도 같은 설계 품질과 깊이 연관돼 있다는 것이다.<br/>

## 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법을 이용해 시스템을 객체로 분할할 수 있다.<br/>
1. 첫 번째 방법은 상태를 분할의 중심으로 삼는 방법이고,<br/>
2. 두 번째 방법은 책임을 분할의 중심축으로 삼는 방법이다.<br/>

데이터 중심의 설계에서는 객체가 포함해야 하는 데이터에 집중한다. 이 객체가 포함해야 하는 데이터는 무엇인가?<br/>
객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심의 설계에 매몰돼 있을 확률이 높다.<br/>
특히 `Movie` 클래스의 경우처럼 객체의 종류를 저장하는 인스턴스 변수와 인스턴스의 종류에 따라 배타적으로 사용될 인스턴스 변수를<br/>
하나의 클래스 안에 함께 포함시키는 방식은 데이터 중심의 설계 안에서 흔히 볼 수 있는 패턴이다.<br/>

## 설계 트레이드 오프

변경될 가능성이 높은 부분을 *구현*이라 부르고 상대적으로 안정적인 부분을 *인터페이스*라고 부른다.<br/>
### __캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법이다.__
유지보수성이 목표다. 두려움 없이, 주저함 없이, 저항감 없이 코드를 변경할 수 있는.<br/>

## 캡슐화 위반

`getter` 와 `setter` 는 특정 인스턴스 변수가 내부에 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다.<br/>
`private` 필드의 `getter` 는 `public` 필드와 다를 것이 없다.<br/>

## 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈 안에 공존할 때 모듈의 응집도가 낮다고 말한다.<br/>
어떤 코드를 수정한 후에 아무런 상관도 없던 코드에 문제가 발생하는 것은 모듈의 응집도가 낮기에 발생하는 대표적인 증상이다.<br/>

## 스스로 자신의 데이터를 책임지는 객체

객체 내부에 저장되는 데이터보다 객체가 협력에 참여하면서 수행할 책임을 정의하는 오퍼레이션이 더 중요하다.<br/>

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

## 캡슐화 위반

메서드의 시그니처를 자세히 살펴보면 특정 타입에 대해 파라미터로 받는데 이는 객체 내부에 특정 타입이 포함돼 있다는 사실을 노출하는 것이다.<br/>
당연히 변경에 대해 내부 구현이 외부로 퍼져나가는 `파급 효과`가 발생하고 캡슐화가 부족하다는 명백한 증거다.<br/>

**캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다.**

## 낮은 응집도

하나의 변경을 수용하기 위해 코드의 여러 곳을 동시에 변경해야 한다는 것은 설계의 응집도가 낮다는 증거다.<br/>

## 데이터 중심 설계의 문제점

- 데이터 중심 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

## 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

데이터는 구현의 일부일뿐이다.<br/>
올바른 객체지향 설계의 무게 중심은 항상 객체의 내부가 아니라 외부에 맞춰져 있어야 한다.<br/>