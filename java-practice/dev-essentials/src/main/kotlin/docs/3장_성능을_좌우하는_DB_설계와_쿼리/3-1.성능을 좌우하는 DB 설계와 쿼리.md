# 성능을 좌우하는 DB 설계와 쿼리

## 성능에 핵심인 DB

DB에 부하가 생기면 DB에 연결된 모든 서버의 응답 시간을 증가시키고 이는 다시 클라이언트에 영향을 준다.  
호출 빈도가 높은 기능에 풀 스캔을 유발하는 쿼리를 작성하는 경우 트래픽이 적을 땐 문제가 되지 않지만 서비스 사용이 본격화되면서  
트래픽이 증가하는 경우 서비스 장애로 이어질 수 있다.  

## 조회 트래픽을 고려한 인덱스 설계

일반적인 시스템에서는 조회 기능의 실행 비율이 높다. (1:9, 2:8)  
같은 게시판이라고 하더라도 사내에서 쓰는 게시판과 인기 커뮤니티 사이트에서 사용하는 게시판은 새로 등록되는 게시글 수에서 차이가 난다.  
DB 테이블을 설계할 때 조회 기능과 트래픽 규모를 고려해야 한다.  

예를 들어 10년 동안 쌓인 게시글 수가 520건에 불과하고 최대 TPS 가 10 미만인 상황에서 조회 성능을 올리기 위해 인덱스를 추가할 필요는 없다.  
반대라면 풀스캔으로 DB 장비의 CPU 사용률이 100%에 도달하지 않도록 적절한 인덱스를 추가해주어야 한다.  

조회 패턴을 기준으로 인덱스를 설계해야 한다.  

`전문 검색 인덱스`

보통 검색 기능은 LIKE '%검색어%' 쿼리를 포함하는데 이는 풀 스캔을 유발한다.  
문자열을 이용한 검색 기능을 위해 엘라스틱서치같은 검색 엔진을 사용하면 DB 를 사용하지 않고 검색 기능을 구현할 수 있다.  
검색 엔진을 구성하기 힘든 상황이라면 전문<sup>full-text</sup> 검색 기능 사용을 고려하자.  
MySQL의 FULL TEXT 인덱스를 사용하면 풀 스캔 없이 문자열 검색 쿼리를 실행할 수 있다.  

### 단일 인덱스와 복합 인덱스

사용자별 활동 내역을 조회할 목적으로 로그성 테이블(activityLog)에 특정 기간을 조회하는 쿼리를 생각해보자.

```SQL
SELECT * 
FROM activityLog 
WHERE userId = 123 
  AND activityDate = '2025-09-20' 
ORDER BY activityDatetime DESC
```

사용자를 식별할 user_id 컬럼의 인덱스는 당연하겠지만 추가적으로 다른 컬럼(ex. activityDate)을 같이 복합 인덱스로 설정해야할지 고민이 될 것이다.  
사용자당 가질 수 있는 데이터가 얼만큼 되는지 가늠해보면 어떤 인덱스를 사용해야 할지 판단하는데 도움이 된다.  

개별 사용자의 평균 활동 내역이 1년에 약 300건이라면 user_id 컬럼에만 인덱스를 추가하는 선택도 나쁘지 않을 것이다.  
개별 사용자의 평균 활동 내역이 1년에 약 10,000건이라면 user_id 컬럼과 activityDate 을 조합한 복합 인덱스를 추가하는 선택이 좋아보인다.  

activityLog 테이블은 통계를 추출하기 위한 목적으로도 사용될 수 있다.

```SQL
SELECT activityDate, activityType, count(activityType)
FROM activityLog
WHERE activityDate = '2025-09-20'
GROUP BY activityType;
```

activityType 컬럼을 인덱스에 포함시켜야할지 고민이다. 이 경우에 쿼리 실행 빈도와 실행 시간을 검토해서 포함 여부를 결정할 수 있다.  
집계된 내용을 별도 테이블에 저장한다면 쿼리 실행 시간이 30초여도 문제가 없다. (하루에 한 번만 실행하기 때문에)  
서비스가 급격하게 커져서 하루에 쌓이는 데이터가 수백만 개에 이르면 activityType 을 인덱스에 포함시켜 커버링 인덱스를 사용할 수 있도록 바꾸자.  

### 선택도를 고려한 인덱스 컬럼 선택

인덱스를 생성할 때는 선택도<sup>selectivity</sup> 가 높은 컬럼을 골라야 한다.  
선택도는 인덱스의 특정 컬럼의 고유한 값 비율을 나타낸다.  

- 선택도가 높으면 고유한 값이 많다
- 선택도가 낮으면 고유한 값이 적다

성별 같은 경우 선택도가 낮아, 인덱스로 조회하더라도 수 많은 데이터들을 다시 필터링해야 한다.  
그렇다고 항상 선택도가 높아야하는 것은 아닌데, 작업 큐를 구현한 테이블이 이에 해당한다.  

```SQL
CREATE TABLE jobqueue (
    jobid   VARCHAR(16)  NOT NULL PRIMARY KEY,
    status  CHAR(1)      NOT NULL
    -- 생략
)
```

status 컬럼이 W(대기), P(작업), C(완료) 3개의 값만 있어 선택도가 낮다.  
하지만 대부분 C(완료) 상태이고 W(대기), P(작업) 상태는 적다.  
WHERE 절에 W 조건이나 P 조건으로 조회하는 경우가 많다면 status 컬럼을 인덱스에 추가하는 것이 유리하다.  

### 커버링 인덱스 활용하기

특정 쿼리를 실행하는데 필요한 모든 컬럼을 포함한 인덱스를 의미한다.  
```SQL
SELECT apple, banana, kiwi
-- 생략
```

apple, banana, kiwi 를 복합 인덱스로 추가하면, 실제 데이터에 접근하지 않는다.  
이미 필요한 컬럼인 apple, banana, kiwi 가 인덱스에 포함되었기 때문이다.  

### 인덱스는 필요한 만큼만 만들기

userId, activityDate, activityType 3개의 컬럼이 있는데 조회 조건으로 자주 사용되는 2개의 쿼리가 있다.  

- WHERE userId ... activityDate
- WHERE userId ... activityDate ... activityType

첫 번째 쿼리는 userId 와 activityDate 로 조건문을 작성하고 두 번째 쿼리는 userId, activityDate, activityType 로 조건문을 작성한다.  
커버링 인데스를 만들 때 두 번째 인덱스가 효과를 보려면 데이터 갯수가 조회 성능에 영향을 줄만큼 많아야 한다.  

인덱스는 조회 성능을 향상 시켜주지만, 데이터의 추가, 변경, 삭제에서는 인덱스 관리에 따른 비용(시간)이 추가되기 때문에 무분별한 추가는 권장되지 않는다.  
새로 추가할 쿼리가 기존에 존재하는 인덱스를 활용하지 못하는 경우 요구 사항을 일부 변경할 수 있는지 검토해보자.  

## 몇 가지 조회 성능 개선 방법



### 미리 집계하기



### 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기



### 조회 범위를 시간 기준으로 제한하기



### 전체 갯수 세지 않기



### 오래된 데이터 삭제 및 분리 보관하기



### DB 장비 확장하기



### 별도 캐시 서버 구성하기



## 알아두면 좋을 몇 가지 주의 사항



### 쿼리 타임 아웃



### 상태 변경 기능은 복제 DB에서 조회하지 않기



### 배치 쿼리 실행 시간 증가



### 타입이 다른 컬럼 조인 주의



### 테이블 변경은 신중하게



### DB 최대 연결 갯수



## 실패와 트랜잭션 고려하기

