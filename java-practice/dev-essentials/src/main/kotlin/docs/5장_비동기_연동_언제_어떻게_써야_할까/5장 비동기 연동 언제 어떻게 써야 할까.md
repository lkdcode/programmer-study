# 🔥 비동기 연동, 언제 어떻게 써야 할까

## 🚀 동기 연동과 비동기 연동

동기<sup>synchronous</sup> 방식은 순차적으로 실행되며 한 작업이 끝날 때까지 다음 작업이 진행되지 않는다.  
동기 방식에서는 코드의 순서가 곧 실행 순서가 된다.  

- 포인트 지급을 실행한 뒤에 로그인 내역을 기록하는 동기 방식

```mermaid
sequenceDiagram
    Client ->>+로그인 서비스: 1: 로그인 요청
    로그인 서비스 ->> DB: 1.1: 회원 데이터 조회
    로그인 서비스 ->>+포인트 서비스: 1.2: 포인트 지급 요청
    포인트 서비스 ->>-로그인 서비스: 1.3: 지급 결과 응답
    로그인 서비스 ->> DB: 1.4: 내역 기록
    로그인 서비스 ->>-Client: 1.5: 결과 응답
```

동기 방식은 외부 연동을 만나면 고려해야할 게 있다.  
포인트 지급 서비스가 외부 연동일 때 포인트 지급 요청에 대한 결과가 실패한 경우 로그인이 실패되는 것은 옳지 않다.  
실패 시 후처리를 할 수 있도록 지급 실패 내역을 따로 관리해야 한다.  

연동하는 외부 서비스의 응답 시간도 고려해야 한다.  
반드시 외부 연동 결과가 필요한 게 아니라면 비동기<sup>Asynchronous</sup> 방식을 고민해보자.  
비동기 방식은 한 작업이 끝날 때까지 기다리지 않고 바로 다음 작업을 처리한다.  

- 비동기로 외부 연동을 하면 사용자는 빠르게 응답을 받을 수 있다.  

```mermaid
sequenceDiagram
    Client ->>로그인 서비스: 1: 로그인 요청
    로그인 서비스 ->> DB: 1.1: 회원 데이터 조회
    로그인 서비스 ->>별도 쓰레드: 1.2: 포인트 지급 요청
    별도 쓰레드 ->>+포인트 서비스 :  2: 포인트 지급 요청
    로그인 서비스 ->> DB: 1.3: 내역 기록
    로그인 서비스 ->>Client: 1.4: 결과 응답
    포인트 서비스 ->>-별도 쓰레드 :  2.1: 지급 격롸 응답
```

바로 포인트가 쌓이지 않으면 문제가 될 것 같지만 수 초 이내에 포인트가 쌓이면 문제가 되지 않을 때가 많다.  
사용자는 로그인 시간이 느린 것보다는 로그인을 빨리 하고 서비스를 사용하는 것을 원한다.  

다음은 비동기 방식이 문제가 되지 몇 가지 예이다.

- 쇼핑몰에서 주문이 들어오면 판매자에게 푸시 보내기 (푸시 서비스 연동)
- 학습을 완료하면 학생에게 포인트 지급 (포인트 서비스 연동)
- 컨텐츠를 등록할 때 검색 서비스에도 등록 (검색 서비스 연동)
- 인증 번호를 요청하면 SMS 로 인증 메시지 발송 (SMS 발송 서비스 연동) 

1. 약간의 시차가 생겨도 문제가 없음 
2. 일부 기능은 실패 시 재시도 가능
3. 연동 실패 시 수동 처리 가능
4. 연동 실패 시 아예 무시해도 무방

여러 특징들을 살펴보고 비동기 방식으로 처리할 수 있는지 검토하여 성능을 개선할 수 있다.

## 🚀 별도 스레드로 실행하기

비동기 연동을 하는 가장 쉬운 방법은 별도 스레드로 실행하는 것이다.  
매번 스레드를 생성하는 대신 스레드 풀을 사용하는 방법도 있다.  

@Async 어노테이션을 사용할 때는 메서드 이름에 비동기 실행과 관련된 단어를 추가하는 것이 좋다.
@Transactional 어노테이션을 사용하여도 비동기는 롤백되지 않고 익셉션도 전파되지 않는다.  
비동기는 오류를 직접 처리해야 하고 코드를 읽는 사람은 비동기로 실행된다는 사실을 알아채기 어렵다.  

### 🎯 스레드와 메모리

스레드는 자체적으로 일정 크기의 메모리를 사용한다.  
운영체제, 언어에 따라 다르지만 순간적으로 많은 스레드를 생성하게 되면 시간이 오래 걸린다.  

스레드 풀을 사용하면 스레드를 일정 개수로 유지할 수 있어 메모리 사용량도 일정하게 유지된다.  
하지만 풀에 생성된 스레드 개수보다 더 많은 작업을 동시에 실행하려면 일부 작업은 다른 작업이 끝날 때까지 대기해야 한다.  

비동기로 실행할 코드가 외부 API 호출이나 DB 연동과 같은 네트워크 IO 작업이라면 자바의 가상 스레드를 사용하는 것도 방법이다.  
경상 스레드로 적은 메모리를 사용한다.  

## 🚀 메시징

- 메시징 시스템을 이용한 비동기 연동 처리

```mermaid
flowchart LR
    시스템_A --메시지 생성/전송--> 메시징_시스템
    메시징_시스템 --메시지 전달--> 시스템_B 
```

구조가 복잡해지지만 다른 이점을 얻을 수 있다.  

- 첫 번째, 두 시스템이 서로 영향을 주지 않는다.

시스템 A 의 트래픽이 급증하여도 시스템 B 의 처리량과 상관없다.  
시스템 B 는 자기 처리량에 맞게 처리하면 될뿐 시스템 A 에 영향을 주지 않는다.
메시징 시스템은 시스템 A 가 보낸 메시지를 일단 저장하고 B 시스템의 성능에 맞게 처리하게 된다. (메시징 시스템마다 다르지만.)  

- 두 번째, 확장이 용이하다.

예를 들어 시스템 A 가 시스템 C 에도 데이터를 전송해야 할 경우 시스템 A 에 관련 코드를 작성하는 것이 아닌,  
시스템 C 가 해당 메시지를 구독하면 된다.  

```mermaid
flowchart LR
    시스템_A --메시지 생성/전송--> 메시징_시스템
    메시징_시스템 --메시지 전달--> 시스템_B
    메시징_시스템 --메시지 전달--> 시스템_C
```

메시징 시스템은 대표적으로 카프카, 래빗 MQ, Redis 등이 있으며  
카프카는 다음과 같은 특징을 가진다.  

- 높은 처리량. 초당 백만 개 이상의 메시지를 처리할 수 있다.  
- 수평 확장 용이. 서버(브로커), 파티션, 소비자를 늘리면 된다.  
- 카프카는 메시지를 파일에 보관해서 메시지가 유실되지 않는다.  
- 1개의 토픽이 여러 파티션을 가질 수 있는데, 파티션 단위로 순서를 보장한다. 하지만 토픽 수준에서는 순서를 보장할 수 없다.
- 소비자는 메시지를 언제든지 재처리할 수 있다.
- 풀(pull) 모델을 사용한다. 소비자가 카프카 브로커에서 메시지를 읽어 가는 방식이다.  

래빗MQ 는 다음과 같은 특징을 가진다.

- 클러스터를 통해 처리량을 높일 수 있다. 단, 카프카보다 더 많은 자원을 필요로 한다.
- 메모리에만 메시지를 보관하는 큐 설정을 사용하면 장애 상황 시 메시지가 유실될 수 있다.
- 메시지는 큐에 등록된 순서대로 소비자에 전송된다.
- 메시지가 소비자에 전달됐는지 확인하는 기능을 제공한다.
- 푸시<sup>push</sup> 모델을 사용한다. 래빗MQ 브로커가 소비자에 메시지를 전송한다. 소비자의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하가 발생할 수 있다.
- 다재 다능하다. AMQP, STOMP 등 여러 프로토콜을 지원하고, 게시/구독 패턴뿐만 아니라 요청/응답, 점대점<sup>point-to-point</sup> 패턴을 지원한다. 또한 우선순위를 지정해서 처리 순서를 변경할 수도 있다.

Redis(pub/sub) 는 다음과 같은 특징을 가진다.

- 메모리를 사용하므로 지연 시간이 짧고, 래빗MQ 대비 처리량이 높다.
- 구독자가 없으면 메시지가 유실된다.
- 기본적으로 영구 메시지를 지원하지 않는다.
- 모델이 단순해서 사용하기 쉽다.

메시지가 유실되어도 상관없다면 레디스 pub/sub 기능을 고려해보자.  
대량의 트래픽(초당 수 십만에서 수 백만 이상)이 발생한다면 카프카를 고려해보자.  
트래픽 규모가 크지 않고 메시지를 정확하게 순서대로 소비자에게 전달해야 하거나 AMQP, STOMP 프로토콜로 연동해야 한다면 래빗MQ 를 고려해보자.  

### 🎯 메시징 생성 측 고려 사항

메시지 유실에 대해 고려해야 한다.  
전송 과정에서의 타임아웃은 네트워크 연결이 불안정할 때 언제든지 발생할 수 있다.  
이때 오류 처리를 위해 다음과 같은 방법을 선택할 수 있다.  

- 무시
- 재시도
- 실패 로그 기록

첫 번째는 메시지가 유실되어도 상관없다면 무시하는 방법이 가장 쉬운 방법이다.  

두 번째는 일시적인 네트워크 불안정과 같은 오류는 재시도를 통해 해결할 수 있다.  
다만, 메시지가 중복될 수 있으므로 고유 식별자를 사용해서 중복 여부를 판단하는 방법 등으로 알맞게 처리해야 한다.  

세 번째는 실패 로그를 기록하여 후처리에 사용하는 방법이다.  

메시지 생산자는 DB 트랜잭션과의 연동도 고려해야 한다.  

- 메시지를 전송한 뒤 DB 트랜잭션이 롤백되면 잘못된 메시지가 전송될 수 있다.  

```mermaid
sequenceDiagram
    고객 ->>+주문 서비스: 1: 주문 요청
    주문 서비스 ->>DB: 1.1: 트랜잭션 시작
    주문 서비스 ->>DB: 1.2: DB 변경
    주문 서비스 ->>메시징 시스템: 1.3: 메시지 전송

    메시징 시스템 ->>+알림 서비스: 1.3.1: 메시지 전파

    주문 서비스 ->>+DB: 1.4: DB 변경
    DB -->>-주문 서비스: 1.5: 변경 실패
    주문 서비스 ->>+DB: 1.6: 트랜잭션 롤백

    주문 서비스 -->>-고객: 1.7: 에러 응답

    알림 서비스 ->>-고객: 1.3.1.1: 주문 안내 푸시 발송
```

잘못된 메시지가 전송되는 문제를 방지하려면 트랜잭션이 끝난 뒤에 메시지를 전송해야 한다.  

- 트랜잭션이 완료(커밋/롤백)된 뒤에 메시지를 전송한다.  

```mermaid
sequenceDiagram
    고객 ->>+주문 서비스: 1: 주문 요청
    주문 서비스 ->>DB: 1.1: 트랜잭션 시작
    주문 서비스 ->>DB: 1.2: DB 변경

    주문 서비스 ->>DB: 1.3: DB 변경
    주문 서비스 ->> DB: 1.4: 트랜잭션 커밋
    
    주문 서비스 ->>메시징 시스템: 1.5: 메시지 전송

    주문 서비스 -->>-고객: 1.6: 성공 응답
    메시징 시스템 ->>+알림 서비스: 1.5.1: 메시지 전파

    알림 서비스 ->>-고객: 1.5.1.1: 주문 안내 푸시 발송
```

### 🎯 글로벌 트랜잭션과 메시지 연동

여러 DB 를 하나의 트랜잭션으로 묶어서 처리할 수 있는 것을 글로벌 트랜잭션<sup>global transaction</sup>이라 한다.  
A DB 와 B DB 를 처리할 때 오류가 발생하면 A 와 B 를 모두 롤백해주며 글로벌 트랜잭션을 구현하는 알고리즘으로 2단계 커밋<sup>2-Phase Commit</sup>을 사용한다. (글로벌 트랜잭션을 2PC 라고 표현하기도 한다.)  

액티브MQ 는 글로벌 트랜잭션을 지원하여 실패에 대한 대응 처리를 단순화할 수 있다.  
모든 메시징 시스템이 지원해주는 것은 아니며 2단계 커밋을 처리하는 과정이 추가되면서 처리 속도가 느려질 수 있다.  

글로벌 트랜잭션이 반드시 필요한 상황이 아니라면 DB 처리와 메시지 연동을 묶지 말자.  
차라리 트랜잭션 아웃박스 패턴을 검토해보자.  

### 🎯 메시징 소비 측 고려 사항

소비자는 다음과 같은 이유로 메시지를 중복 처리할 수 있다.  

- 메시지 생산자가 같은 데이터를 가진 메시지를 메시징 시스템에 2번 전송
- 소비자가 메시지를 처리하는 과정에서 오류가 발생하여 메시지 재수신

메시지에 식별 가능한 고유 ID 를 부여하면 중복 처리를 방지할 수 있다.  

메시지를 처리하는 과정에서 오류가 발생하면 재처리를 위해 메시지를 다시 수신할 수 있다.  
읽기 타임아웃이 발생하여 메시지 처리에 실패한다면 같은 메시지를 재수신하여 재시도할 수 있다.  

멱등성을 갖도록 API 를 구현한다면 매 요청마다 같은 결과를 얻을 수 있으므로 중복 메시지 처리에 유용하다.  

중복 메시지 처리와 함께 고려해야할 것은 소비자가 메시지를 잘 처리하고 있는지다.  
소비자의 처리 속도가 느려지면 메시징 시스템에 메시지가 쌓이게 되고 생산자가 메시징 시스템에 메시지를 추가할 수 없는 상황이 발생할 수 있다.  
소비자의 성능 저하가 생산자까지 영향을 줄 수 있는 것이다.  

### 🎯 메시지 종류: 이벤트와 커맨드



## 🚀 트랜잭션 아웃박스 패턴



### 🎯 아웃박스 테이블 구조



## 🚀 배치 전송



### 🎯 재처리 기능 만들기



## 🚀 CDC



### 🎯 CDC 와 데이터 위치



### 🎯 CDC 가 유용할 때


