# 🔥 concurrency-problem

서로 다른 스레드가 하나의 자원을 놓고 수정하는 과정에서 동시성 문제가 발생한다.  
<u>**재고가 100개고 100명이 동시에 요청했을 때 재고는 0이 되는가?**</u>  

동시성 문제를 유발시키고 다양한 방법으로 해결해보자.  

1. 그냥 해보기
2. 비관적 락
    1. 애플리케이션 수준
    2. 데이터베이스 수준
3. 낙관적 락
    1. 애플리케이션 수준
    2. 데이터베이스 수준
4. 단일 스레드 처리

## 🚀 1. 문제 발생

재고가 100개고 동시 요청자가 100명이니 재고는 0 신청자 수는 100이 되어야 한다.  
재고가 음수가 되는 경우와 중복 신청을 막아주고 신청자 1명당 1개의 재고를 차감해준다.  

실행 결과를 보면 신청자 수는 100명으로 올바르지만, 남은 재고는 88개로 누락된 것을 확인할 수 있다.  
실행할 때마다 결과는 달라지지만 중요한 것은 재고 차감이 누락되는 것이다.  

```mermaid
sequenceDiagram
   Note left of EventStock: 현재 재고: 93
   EventStock ->> 스레드1: 현재 재고: 93
   EventStock ->> 스레드2: 현재 재고: 93
   스레드1 ->> EventStock: 재고 변경 93 → 92
   Note left of EventStock: 현재 재고: 92
   스레드2 ->> EventStock: 재고 변경 93 → 92
   Note left of EventStock: 🔥 현재 재고: 92
```

## 🚀 2. 비관적 락

비관적 락은 실패할 가능성이 높아서 비관적이다. 정상적으로 변경할 가능성이 떨어지므로 선점 잠금을 통해 동시성 문제에 대응한다.  
Java/Kotlin 과 같은 애플리케이션 수준에서의 락과 MySQL 과 같은 데이터베이스 수준에서의 락으로 해결해보자.  

## 🎯 2-1. Application 비관적 락

크게 `synchronized` 와 `ReentrantLock` 을 사용해서 구현할 수 있다.  

`synchronized` 는 자동 락 해제와 상대적으로 쉽게 사용할 수 있고 `ReentrantLock` 는 조금 더 정밀 제어가 가능하다.  
`ReentrantLock` 는 `synchronized` 에 없는 기능들을 제공하는데 대표적으로 잠금 획득 대기 시간을 지정하는 기능이 있다.  

실행 결과는 항상 성공하게 되는데, 이유는 싱글톤 빈 + 단일 JVM 환경에서 비관적 락은 늘 성공한다.  
실패를 유발하려면 멀티 빈, 멀티 JVM 등 분산 환경에서 사용하면 실패할 것이다.  

## 🎯 2-2. Database 비관적 락

DB 수준 비관적 락은 Row 를 잡고 직렬화 하게 만든다.  


## 🚀 3. 낙관적 락

## 🚀 4.